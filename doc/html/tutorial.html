<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Tutorial and Motivating Examples</title>
<link rel="stylesheet" href="boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.1">
<link rel="home" href="index.html" title="Safe Numerics">
<link rel="up" href="index.html" title="Safe Numerics">
<link rel="prev" href="introduction.html" title="Introduction">
<link rel="next" href="notes.html" title="Notes">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img href="index.html" height="164px" src="pre-boost.jpg" alt="Library Documentation Index"></td>
<td><h2>Safe Numerics</h2></td>
</tr></table>
<div class="spirit-nav">
<a accesskey="p" href="introduction.html"><img src="images/prev.png" alt="Prev"></a><a accesskey="u" href="index.html"><img src="images/up.png" alt="Up"></a><a accesskey="h" href="index.html"><img src="images/home.png" alt="Home"></a><a accesskey="n" href="notes.html"><img src="images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="safe_numerics.tutorial"></a>Tutorial and Motivating Examples</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="tutorial.html#safe_numerics.tutorial.1">Arithmetic operations can yield incorrect results.</a></span></dt>
<dt><span class="section"><a href="tutorial.html#safe_numerics.tutorial.2">Undetected overflow</a></span></dt>
<dt><span class="section"><a href="tutorial.html#safe_numerics.tutorial.3">Undetected underflow</a></span></dt>
<dt><span class="section"><a href="tutorial.html#safe_numerics.tutorial.4">Implicit conversions change data values</a></span></dt>
<dt><span class="section"><a href="tutorial.html#safe_numerics.tutorial.5">Array index value can exceed array limits</a></span></dt>
<dt><span class="section"><a href="tutorial.html#safe_numerics.tutorial.6">Checking of initialization values can be easily overlooked</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="safe_numerics.tutorial.1"></a>Arithmetic operations can yield incorrect results.</h3></div></div></div>
<p>When some operation results in a result which exceeds the capacity
    of a data variable to hold it, the result is undefined. This is called
    "overflow". Since word size can differ between machines, code which
    produces correct results in one set of circumstances may fail when
    re-compiled on a machine with different hardware. When this occurs, Most
    C++ compilers will continue to execute with no indication that the results
    are wrong. It is the programmer's responsibility to ensure such undefined
    behavior is avoided.</p>
<p>This program demonstrates this problem. The solution is to replace
    instances of <code class="computeroutput">char</code> type with <code class="computeroutput">safe&lt;char&gt;</code>
    type.</p>
<pre class="programlisting">#include &lt;cassert&gt;
#include &lt;stdexcept&gt;
#include &lt;iostream&gt;

#include "../include/safe_integer.hpp"

void detected_msg(bool detected){
    std::cout &lt;&lt; (detected ? "error detected!" : "error NOT detected! ") &lt;&lt; std::endl;
}

int main(int argc, const char * argv[]){
    // problem: undetected erroneous expression evaluation
    std::cout &lt;&lt; "example 1:";
    std::cout &lt;&lt; "undetected erroneous expression evaluation" &lt;&lt; std::endl;
    std::cout &lt;&lt; "Not using safe numerics" &lt;&lt; std::endl;

    signed char x = 127;
    signed char y = 2;
    signed char z;
    // this produces an invalid result !
    z = x + y;
    assert(z != 129); // compiler may emit warning here
    // but assert fails to detect it since C++ implicitly
    // converts variables to int before evaluating he expression!
    assert(z != x + y);
    std::cout &lt;&lt; static_cast&lt;int&gt;(z) &lt;&lt; " != " &lt;&lt; x + y &lt;&lt; std::endl;
    detected_msg(false);
    
    // solution: replace char with safe&lt;char&gt;
    std::cout &lt;&lt; "Using safe numerics" &lt;&lt; std::endl;
    try{
        using namespace boost::numeric;
        safe&lt;signed char&gt; x = 127;
        safe&lt;signed char&gt; y = 2;
        safe&lt;signed char&gt; z;
        // rather than producing an invalid result an exception is thrown
        z = x + y;
        assert(false); // we never arrive here
    }
    catch(std::range_error &amp; e){
        // which can catch here
        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
        detected_msg(true);
    }
    return 0;
}
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="safe_numerics.tutorial.2"></a>Undetected overflow</h3></div></div></div>
<p>A variation of the above is when a value is incremented/decremented
    beyond it's domain. This is a common problem with for loops.</p>
<pre class="programlisting">#include &lt;cassert&gt;
#include &lt;stdexcept&gt;
#include &lt;iostream&gt;

#include "../include/safe_integer.hpp"

void detected_msg(bool detected){
    std::cout &lt;&lt; (detected ? "error detected!" : "error NOT detected! ") &lt;&lt; std::endl;
}

int main(int argc, const char * argv[]){
    // solution: undetected overflow in data type
    std::cout &lt;&lt; "example 2:";
    std::cout &lt;&lt; "undetected overflow in data type" &lt;&lt; std::endl;

    int x = INT_MAX;
    // the following silently produces an incorrect result
    ++x;
    std::cout &lt;&lt; x &lt;&lt; " != " &lt;&lt; INT_MAX &lt;&lt; " + 1" &lt;&lt; std::endl;
    detected_msg(false);

    // solution: replace int with safe&lt;int&gt;
    try{
        using namespace boost::numeric;
        safe&lt;int&gt; x = INT_MAX;
        // throws exception when result is past maximum possible 
        ++x;
        assert(false); // we never arrive here
    }
    catch(std::range_error &amp; e){
        std::cout &lt;&lt; e.what();
        detected_msg(true);
    }
    return 0;
}
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="safe_numerics.tutorial.3"></a>Undetected underflow</h3></div></div></div>
<p>A variation of the above is when a value is incremented/decremented
    beyond it's domain. This is a common problem with for loops.</p>
<pre class="programlisting">#include &lt;cassert&gt;
#include &lt;stdexcept&gt;
#include &lt;iostream&gt;

#include "../include/safe_integer.hpp"
#include "../include/safe_compare.hpp"

void detected_msg(bool detected){
    std::cout &lt;&lt; (detected ? "error detected!" : "error NOT detected! ") &lt;&lt; std::endl;
}

int main(int argc, const char * argv[]){
    std::cout &lt;&lt; "example 3:";
    std::cout &lt;&lt; "undetected underflow in data type" &lt;&lt; std::endl;
    std::cout &lt;&lt; "Not using safe numerics" &lt;&lt; std::endl;

    unsigned int x = 0;
    // the following silently produces an incorrect result
    --x;
    // because C/C++ implicitly converts mis-matched arguments to int
    // suggests that the operation is correct
    assert(x == -1);
    // even though it's not !!!

    // however, safe_compare does detect the error
    assert(! boost::numeric::safe_compare::equal(x, -1));
    std::cout &lt;&lt; x &lt;&lt; " != " &lt;&lt; -1;

    // solution: replace unsigned int with safe&lt;unsigned int&gt;
    std::cout &lt;&lt; "Using safe numerics" &lt;&lt; std::endl;
    try{
        using namespace boost::numeric;
        safe&lt;unsigned int&gt; x = 0;
        // decrement unsigned to less than zero throws exception
        --x;
        assert(false); // never arrive here
    }
    catch(std::range_error &amp; e){
        std::cout &lt;&lt; e.what();
        detected_msg(true);
    }
    return 0;
}
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="safe_numerics.tutorial.4"></a>Implicit conversions change data values</h3></div></div></div>
<p>A simple assignment or arithmetic expression will generally convert
    all the terms to the same type. Sometimes this can silently change values.
    For example, when a signed data variable contains a negative type,
    assigning to a unsigned type will be permitted by any C/C++ compiler but
    will be treated as large unsigned value. Most modern compilers will emit a
    compile time warning when this conversion is performed. The user may then
    decide to change some data types or apply a <code class="computeroutput">static_cast</code>. This
    is less than satisfactory for two reasons:</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>It may be unwieldy to change all the types to signed or
          unsigned.</p></li>
<li class="listitem"><p>Littering one's program with <code class="computeroutput">static_cast</code><code class="computeroutput">
          </code>makes it more difficult to read.</p></li>
<li class="listitem"><p>We may believe that our signed type will never contain a
          negative value. If we use a <code class="computeroutput">static_cast</code> to suppress the
          warning, we'll fail to detect a program error when it is committed.
          This is aways a risk with casts.</p></li>
</ul></div>
<p>This solution is the same as the above, Just replace instances of
    the <code class="computeroutput">int </code>with <code class="computeroutput">safe&lt;int&gt;</code>.</p>
<pre class="programlisting">#include &lt;cassert&gt;
#include &lt;stdexcept&gt;
#include &lt;iostream&gt;

#include "../include/safe_integer.hpp"

void detected_msg(bool detected){
    std::cout &lt;&lt; (detected ? "error detected!" : "error NOT detected! ") &lt;&lt; std::endl;
}

int main(int argc, const char * argv[]){
    // problem: implicit conversions change data values
    std::cout &lt;&lt; "example 4: ";
    std::cout &lt;&lt; "implicit conversions change data values" &lt;&lt; std::endl;
    std::cout &lt;&lt; "Not using safe numerics" &lt;&lt; std::endl;

    int x = -1000;
    // the following silently produces an incorrect result
    char y = x;
    detected_msg(false);

    // solution: replace int with safe&lt;int&gt; and char with safe&lt;char&gt;
    std::cout &lt;&lt; "Using safe numerics" &lt;&lt; std::endl;
    try{
        using namespace boost::numeric;
        safe&lt;int&gt; x = -1000;
        // throws exception when conversion change data value
        safe&lt;char&gt; y = x;
        assert(false); // never arrive here
    }
    catch(std::range_error &amp; e){
        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
        detected_msg(true);
    }
    return 0;
}
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="safe_numerics.tutorial.5"></a>Array index value can exceed array limits</h3></div></div></div>
<p>Using an intrinsic C++ array, it's very easy to exceed array limits.
    This can fail to be detected when it occurs and create bugs which are hard
    to find. There are several ways to address this, but one of the simplest
    would be to use safe_unsigned_range;</p>
<pre class="programlisting">#include &lt;cassert&gt;
#include &lt;stdexcept&gt;
#include &lt;iostream&gt;

#include "../include/safe_range.hpp"

void detected_msg(bool detected){
    std::cout &lt;&lt; (detected ? "error detected!" : "error NOT detected! ") &lt;&lt; std::endl;
}

int main(int argc, const char * argv[]){
    // problem: array index values can exceed array bounds
    std::cout &lt;&lt; "example 5: ";
    std::cout &lt;&lt; "array index values can exceed array bounds" &lt;&lt; std::endl;
    std::cout &lt;&lt; "Not using safe numerics" &lt;&lt; std::endl;
    int i_array[37];

    unsigned int i_index = 43;
    // the following corrupts memory.
    // This may or may not be detected at run time.
    // i_array[i_index] = 84; // comment this out so it can be tested!
    detected_msg(false);

    // solution: replace unsigned array index with safe_unsigned_range
    std::cout &lt;&lt; "Using safe numerics" &lt;&lt; std::endl;
    try{
        using namespace boost::numeric;
        safe_unsigned_range&lt;0, sizeof(i_array)/sizeof(int) - 1&gt; i_index;
        i_index = 36; // this works fine
        i_array[i_index] = 84;
        i_index = 37; // throw exception here!
        i_array[i_index] = 84; // so we never arrive here
        assert(false);
    }
    catch(std::range_error &amp; e){
        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
        detected_msg(true);
    }
    return 0;
}
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="safe_numerics.tutorial.6"></a>Checking of initialization values can be easily overlooked</h3></div></div></div>
<p>It's way too easy to overlook the checking of parameters received
    from outside the current program.</p>
<pre class="programlisting">#include &lt;cassert&gt;
#include &lt;stdexcept&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;

#include "../include/safe_integer.hpp"

void detected_msg(bool detected){
    std::cout &lt;&lt; (detected ? "error detected!" : "error NOT detected! ") &lt;&lt; std::endl;
}

int main(int argc, const char * argv[]){
    // problem: checking of externally produced value can be overlooked
    std::cout &lt;&lt; "example 6: ";
    std::cout &lt;&lt; "checking of externally produced value can be overlooked" &lt;&lt; std::endl;
    std::cout &lt;&lt; "Not using safe numerics" &lt;&lt; std::endl;

    std::istringstream is("12317289372189 1231287389217389217893");

    int x, y, z;
    is &gt;&gt; x &gt;&gt; y; // get integer values from the user
    z = x + y;
    std::cout &lt;&lt; z &lt;&lt; std::endl;  // display sum of the values
    detected_msg(false);
    
    // solution: asign externally retrieved values to safe equivalents
    std::cout &lt;&lt; "Using safe numerics" &lt;&lt; std::endl;
    {
        using namespace boost::numeric;
        safe&lt;int&gt; x, y, z;
        is.seekg(0);
        try{
            is &gt;&gt; x &gt;&gt; y; // get integer values from the user
            detected_msg(false);
        }
        catch(std::range_error &amp; e){
            std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
            detected_msg(true);
        }
        try{
            z = x + y;
            detected_msg(false);
        }
        catch(std::exception e){
            std::cout &lt;&lt; z &lt;&lt; std::endl;  // display sum of the values
            detected_msg(true);
        }
    }
    return 0;
}
</pre>
<p>Without
    safe integer, one will have to insert new code every time an integer
    variable is retrieved. This is a tedious and error prone procedure.</p>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2012 Robert Ramey<p><a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt"&gt;Subject
      to Boost Software License</a></p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="introduction.html"><img src="images/prev.png" alt="Prev"></a><a accesskey="u" href="index.html"><img src="images/up.png" alt="Up"></a><a accesskey="h" href="index.html"><img src="images/home.png" alt="Home"></a><a accesskey="n" href="notes.html"><img src="images/next.png" alt="Next"></a>
</div>
</body>
</html>
