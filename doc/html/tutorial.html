<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Tutorial and Motivating Examples</title>
<link rel="stylesheet" href="boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.1">
<link rel="home" href="index.html" title="Safe Numerics">
<link rel="up" href="index.html" title="Safe Numerics">
<link rel="prev" href="introduction.html" title="Introduction">
<link rel="next" href="notes.html" title="Notes">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img href="index.html" height="164px" src="pre-boost.jpg" alt="Library Documentation Index"></td>
<td><h2>Safe Numerics</h2></td>
</tr></table>
<div class="spirit-nav">
<a accesskey="p" href="introduction.html"><img src="images/prev.png" alt="Prev"></a><a accesskey="u" href="index.html"><img src="images/up.png" alt="Up"></a><a accesskey="h" href="index.html"><img src="images/home.png" alt="Home"></a><a accesskey="n" href="notes.html"><img src="images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="safe_numerics.tutorial"></a>Tutorial and Motivating Examples</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="tutorial.html#safe_numerics.tutorial.1">Arithmetic operations can yield incorrect results.</a></span></dt>
<dt><span class="section"><a href="tutorial.html#safe_numerics.tutorial.2">Undetected overflow</a></span></dt>
<dt><span class="section"><a href="tutorial.html#safe_numerics.tutorial.3">Undetected underflow</a></span></dt>
<dt><span class="section"><a href="tutorial.html#safe_numerics.tutorial.4">Implicit conversions change data values</a></span></dt>
<dt><span class="section"><a href="tutorial.html#safe_numerics.tutorial.5">Array index value can exceed array limits</a></span></dt>
<dt><span class="section"><a href="tutorial.html#safe_numerics.tutorial.6">Checking of initialization values can be easily overlooked</a></span></dt>
<dt><span class="section"><a href="tutorial.html#idm236255083040">Parameter checking is too expensive</a></span></dt>
<dt><span class="section"><a href="tutorial.html#idm236255078592">Eliminate runtime cost</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="safe_numerics.tutorial.1"></a>Arithmetic operations can yield incorrect results.</h3></div></div></div>
<p>When some operation results in a result which exceeds the capacity
    of a data variable to hold it, the result is undefined. This is called
    "overflow". Since word size can differ between machines, code which
    produces correct results in one set of circumstances may fail when
    re-compiled on a machine with different hardware. When this occurs, Most
    C++ compilers will continue to execute with no indication that the results
    are wrong. It is the programmer's responsibility to ensure such undefined
    behavior is avoided.</p>
<p>This program demonstrates this problem. The solution is to replace
    instances of <code class="computeroutput">char</code> type with <code class="computeroutput">safe&lt;char&gt;</code>
    type.</p>
<pre class="programlisting">#include &lt;cassert&gt;
#include &lt;exception&gt;
#include &lt;iostream&gt;

#include "../include/safe_integer.hpp"

void detected_msg(bool detected){
    std::cout &lt;&lt; (detected ? "error detected!" : "error NOT detected! ") &lt;&lt; std::endl;
}

int main(int argc, const char * argv[]){
    std::cout &lt;&lt; "example 1:";
    std::cout &lt;&lt; "undetected erroneous expression evaluation" &lt;&lt; std::endl;
    std::cout &lt;&lt; "Not using safe numerics" &lt;&lt; std::endl;
    try{
        char x = 127;
        char y = 2;
        char z;
        // this produces an invalid result !
        z = x + y;
        // it is the wrong result !!!
        assert(z != 129);
        // but assert fails to detect it since C++ implicitly
        // converts variables to int before evaluating he expression!
        assert(z != x + y);
        std::cout &lt;&lt; static_cast&lt;int&gt;(z) &lt;&lt; " != " &lt;&lt; x + y &lt;&lt; std::endl;
        detected_msg(false);
    }
    catch(std::exception){
        assert(false); // never arrive here
    }
    // solution: replace char with safe&lt;char&gt;
    std::cout &lt;&lt; "Using safe numerics" &lt;&lt; std::endl;
    try{
        using namespace boost::numeric;
        safe&lt;char&gt; x = 127;
        safe&lt;char&gt; y = 2;
        safe&lt;char&gt; z;
        // rather than producing and invalid result an exception is thrown
        z = x + y;
        assert(false); // never arrive here
    }
    catch(std::exception &amp; e){
        // which can catch here
        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
        detected_msg(true);
    }
    return 0;
}
</pre>
<p>Note that I've used <code class="computeroutput">char</code> types in this example to make
    the problem and solution easier to see. The exact same example could have
    been done with <code class="computeroutput">int</code> types albeit with different values.</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="safe_numerics.tutorial.2"></a>Undetected overflow</h3></div></div></div>
<p>A variation of the above is when a value is incremented/decremented
    beyond it's domain. This is a common problem with for loops.</p>
<pre class="programlisting">#include &lt;cassert&gt;
#include &lt;exception&gt;
#include &lt;iostream&gt;

#include "../include/safe_integer.hpp"

void detected_msg(bool detected){
    std::cout &lt;&lt; (detected ? "error detected!" : "error NOT detected! ") &lt;&lt; std::endl;
}

int main(int argc, const char * argv[]){
    std::cout &lt;&lt; "example 2:";
    std::cout &lt;&lt; "undetected overflow in data type" &lt;&lt; std::endl;
    try{
        int x = INT_MAX;
        // the following silently produces an incorrect result
        ++x;
        std::cout &lt;&lt; x &lt;&lt; " != " &lt;&lt; INT_MAX &lt;&lt; " + 1" &lt;&lt; std::endl;
        detected_msg(false);
    }
    catch(std::exception){
        assert(false); // never arrive here
    }
    // solution: replace int with safe&lt;int&gt;
    try{
        using namespace boost::numeric;
        safe&lt;int&gt; x = INT_MAX;
        // throws exception when result is past maximum possible 
        ++x;
        assert(false); // never arrive here
    }
    catch(std::exception &amp; e){
        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
        detected_msg(true);
    }
    return 0;
}
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="safe_numerics.tutorial.3"></a>Undetected underflow</h3></div></div></div>
<p>A variation of the above is when a value is incremented/decremented
    beyond it's domain. This is a common problem with for loops.</p>
<pre class="programlisting">#include &lt;cassert&gt;
#include &lt;exception&gt;
#include &lt;iostream&gt;

#include "../include/safe_integer.hpp"

void detected_msg(bool detected){
    std::cout &lt;&lt; (detected ? "error detected!" : "error NOT detected! ") &lt;&lt; std::endl;
}

int main(int argc, const char * argv[]){
    std::cout &lt;&lt; "example 3:";
    std::cout &lt;&lt; "undetected underflow in data type" &lt;&lt; std::endl;
    std::cout &lt;&lt; "Not using safe numerics" &lt;&lt; std::endl;
    try{
        unsigned int x = 0;
        // the following silently produces an incorrect result
        --x;
        // because C/C++ implicitly converts mis-matched arguments to int
        // suggests that the operation is correct
        assert(x == -1);
        // even though it's not !!!

        // so the error is not detected!
        std::cout &lt;&lt; x &lt;&lt; " != " &lt;&lt; -1 &lt;&lt; std::endl;
        detected_msg(false);
    }
    catch(std::exception){
        assert(false); // never arrive here
    }
    // solution: replace unsigned int with safe&lt;unsigned int&gt;
    std::cout &lt;&lt; "Using safe numerics" &lt;&lt; std::endl;
    try{
        using namespace boost::numeric;
        safe&lt;unsigned int&gt; x = 0;
        // decrement unsigned to less than zero throws exception
        --x;
        assert(false); // never arrive here
    }
    catch(std::exception &amp; e){
        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
        detected_msg(true);
    }
    return 0;
}
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="safe_numerics.tutorial.4"></a>Implicit conversions change data values</h3></div></div></div>
<p>A simple assignment or arithmetic expression will generally convert
    all the terms to the same type. Sometimes this can silently change values.
    For example, when a signed data variable contains a negative type,
    assigning to a unsigned type will be permitted by any C/C++ compiler but
    will be treated as large unsigned value. Most modern compilers will emit a
    compile time warning when this conversion is performed. The user may then
    decide to change some data types or apply a <code class="computeroutput">static_cast</code>. This
    is less than satisfactory for two reasons:</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>It may be unwieldy to change all the types to signed or
          unsigned.</p></li>
<li class="listitem"><p>Littering one's program with <code class="computeroutput">static_cast</code><code class="computeroutput">
          </code>makes it more difficult to read.</p></li>
<li class="listitem"><p>We may believe that our signed type will never contain a
          negative value. If we ignore the any compiler warnings or use a
          <code class="computeroutput">static_cast</code> to suppress them, we'll fail to detect a
          program error when it is committed. This is aways a risk with
          casts.</p></li>
</ul></div>
<p>This solution is simple, Just replace instances of the <code class="computeroutput">int
    </code>with <code class="computeroutput">safe&lt;int&gt;</code>.</p>
<pre class="programlisting">#include &lt;cassert&gt;
#include &lt;exception&gt;
#include &lt;iostream&gt;

#include "../include/safe_integer.hpp"

void detected_msg(bool detected){
    std::cout &lt;&lt; (detected ? "error detected!" : "error NOT detected! ") &lt;&lt; std::endl;
}

int main(int argc, const char * argv[]){
    std::cout &lt;&lt; "example 4: ";
    std::cout &lt;&lt; "implicit conversions change data values" &lt;&lt; std::endl;
    std::cout &lt;&lt; "Not using safe numerics" &lt;&lt; std::endl;
    try{
        int x = -1000;
        // the following silently produces an incorrect result
        char y = x;
        detected_msg(false);
    }
    catch(std::exception){
        assert(false); // never arrive here
    }
    // solution: replace int with safe&lt;int&gt; and char with safe&lt;char&gt;
    std::cout &lt;&lt; "Using safe numerics" &lt;&lt; std::endl;
    try{
        using namespace boost::numeric;
        safe&lt;int&gt; x = -1000;
        // throws exception when conversion change data value
        safe&lt;char&gt; y1(x);
        safe&lt;char&gt; y3 = x;
        safe&lt;char&gt; y = {x};
        y = x;
        assert(false); // never arrive here
    }
    catch(std::exception &amp; e){
        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
        detected_msg(true);
    }
    return 0;
}
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="safe_numerics.tutorial.5"></a>Array index value can exceed array limits</h3></div></div></div>
<p>Using an intrinsic C++ array, it's very easy to exceed array limits.
    This can fail to be detected when it occurs and create bugs which are hard
    to find. There are several ways to address this, but one of the simplest
    would be to use safe_unsigned_range;</p>
<pre class="programlisting">#include &lt;cassert&gt;
#include &lt;stdexcept&gt;
#include &lt;iostream&gt;

#include "../include/safe_range.hpp"

void detected_msg(bool detected){
    std::cout &lt;&lt; (detected ? "error detected!" : "error NOT detected! ") &lt;&lt; std::endl;
}

int main(int argc, const char * argv[]){
    // problem: array index values can exceed array bounds
    std::cout &lt;&lt; "example 5: ";
    std::cout &lt;&lt; "array index values can exceed array bounds" &lt;&lt; std::endl;
    std::cout &lt;&lt; "Not using safe numerics" &lt;&lt; std::endl;
    int i_array[37];

    unsigned int i_index = 43;
    // the following corrupts memory.
    // This may or may not be detected at run time.
    // i_array[i_index] = 84; // comment this out so it can be tested!
    detected_msg(false);

    // solution: replace unsigned array index with safe_unsigned_range
    std::cout &lt;&lt; "Using safe numerics" &lt;&lt; std::endl;
    try{
        using namespace boost::numeric;
        safe_unsigned_range&lt;0, sizeof(i_array)/sizeof(int) - 1&gt; i_index;
        i_index = 36; // this works fine
        i_array[i_index] = 84;
        i_index = 37; // throw exception here!
        i_array[i_index] = 84; // so we never arrive here
        assert(false);
    }
    catch(std::exception &amp; e){
        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
        detected_msg(true);
    }
    return 0;
}
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="safe_numerics.tutorial.6"></a>Checking of initialization values can be easily overlooked</h3></div></div></div>
<p>It's way too easy to overlook the checking of parameters received
    from outside the current program.</p>
<pre class="programlisting">#include &lt;cassert&gt;
#include &lt;stdexcept&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;

#include "../include/safe_integer.hpp"

void detected_msg(bool detected){
    std::cout &lt;&lt; (detected ? "error detected!" : "error NOT detected! ") &lt;&lt; std::endl;
}

int main(int argc, const char * argv[]){
    // problem: checking of externally produced value can be overlooked
    std::cout &lt;&lt; "example 6: ";
    std::cout &lt;&lt; "checking of externally produced value can be overlooked" &lt;&lt; std::endl;
    std::cout &lt;&lt; "Not using safe numerics" &lt;&lt; std::endl;

    std::istringstream is("12317289372189 1231287389217389217893");

    int x, y, z;
    is &gt;&gt; x &gt;&gt; y; // get integer values from the user
    z = x + y;
    std::cout &lt;&lt; z &lt;&lt; std::endl;  // display sum of the values
    detected_msg(false);
    
    // solution: asign externally retrieved values to safe equivalents
    std::cout &lt;&lt; "Using safe numerics" &lt;&lt; std::endl;
    {
        using namespace boost::numeric;
        safe&lt;int&gt; x, y, z;
        is.seekg(0);
        try{
            is &gt;&gt; x &gt;&gt; y; // get integer values from the user
            detected_msg(false);
        }
        catch(std::exception e){
            std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
            detected_msg(true);
        }
    }
    return 0;
}
</pre>
<p>Without
    safe integer, one will have to insert new code every time an integer
    variable is retrieved. This is a tedious and error prone procedure.</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="idm236255083040"></a>Parameter checking is too expensive</h3></div></div></div>
<p>Programming by Contract is a highly regarded technique. There has
    been much written about it has been proposed as an addition to the C++
    language [<a class="citation" href="bibliography.html#idm236254531664"><span class="citation">Garcia</span></a>][<span class="citation">Crowl &amp;
    Ottosen</span>]. It (mostly depends upon runtime checking of parameter
    values upon entry to every function and thus slows the program down. This
    undermines the main motivation for using C++ in the first place! One
    popular scheme for addressing this issue is to enable parameter checking
    only during debugging and testing. This defeats the guarentee of
    correctness which we are seeking here! This library has facilities which,
    in many cases, can check guarentee parameter requirements with no runtime
    overhead. Consider the following example:</p>
<pre class="programlisting">#include &lt;cassert&gt;
#include &lt;stdexcept&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;

#include "../include/safe_range.hpp"

// return total number of minutes
unsigned int convert(
    const unsigned int &amp; hours,
    const unsigned int &amp; minutes
) {
    // check that parameters are within required limits
    // invokes a runtime cost EVERYTIME the function is called
    // and the overhead of supporting an interrupt.
    // note high runtime cost!
    if(minutes &gt; 59)
        throw std::domain_error("minutes exceeded 59");
    if(hours &gt; 23)
        throw std::domain_error("hours exceeded 23");
    return hours * 60 + minutes;
}

// define convient typenames for hours and minutes hh:mm
using hours_t = boost::numeric::safe_unsigned_range&lt;0, 23&gt;;
using minutes_t = boost::numeric::safe_unsigned_range&lt;0, 59&gt;;

// return total number of minutes
// type returned is safe_unsigned_range&lt;0, 24*60 - 1&gt;
auto safe_convert(const hours_t &amp; hours, const minutes_t &amp; minutes) {
    // no need for checking as parameters are guaranteed to be within limits
    // expression below cannot throw ! zero runtime overhead
    return hours * 60 + minutes;
}

int main(int argc, const char * argv[]){
    std::cout &lt;&lt; "example 7: ";
    std::cout &lt;&lt; "enforce contracts with zero runtime cost" &lt;&lt; std::endl;
    std::cout &lt;&lt; "Not using safe numerics" &lt;&lt; std::endl;

    // problem: checking of externally produced value can be expensive
    try {
        convert(10, 83); // invalid parameters - detected - but at a heavy cost
    }
    catch(std::exception e){
        std::cout &lt;&lt; "exception thrown for parameter error" &lt;&lt; std::endl;
    }

    // solution: use safe range to restrict parameters
    std::cout &lt;&lt; "Using safe numerics" &lt;&lt; std::endl;

    try {
        // parameters are guarenteed to meet requirements
        hours_t hours(10);
        minutes_t minutes(83);  // interrupt thrown here
        // so the following will never throw
        safe_convert(hours, minutes);
    }
    catch(std::exception e){
        std::cout
            &lt;&lt; "exception thrown when invalid arguments are constructed"
            &lt;&lt; std::endl;
    }

    try {
        // parameters are guarenteed to meet requirements when
        // constructed on the stack
        safe_convert(hours_t(10), minutes_t(83));
    }
    catch(std::exception e){
        std::cout
            &lt;&lt; "exception thrown when invalid arguments are constructed on the stack"
            &lt;&lt; std::endl;
    }

    try {
        // parameters are guarenteed to meet requirements when
        // implicitly constructed to safe types to match function signature
        safe_convert(10, 83);
    }
    catch(std::exception e){
        std::cout
            &lt;&lt; "exception thrown when invalid arguments are implicitly constructed"
            &lt;&lt; std::endl;
    }

    try {
        // the following will never throw as the values meet requirements.
        hours_t hours(10);
        minutes_t minutes(17);

        // the following will never throw because it cannot be called with
        // invalid parameters
        safe_convert(hours, minutes);

        // since safe types can be converted to their underlying unsafe types
        // we can still call an unsafe function with safe types
        convert(hours, minutes);

        // since unsafe types can be implicitly converted to corresponding
        // safe types we can just pass the unsafe types.  checkin will occur
        // when the safe type is constructed.
        safe_convert(10, 17);

        // note zero runtime overhead once values are constructed
    }
    catch(std::exception e){
        assert(false); // can never arrive here !!!
    }

    return 0;
}
</pre>
<p>In the example above the function convert incurrs significant
    runtime cost every time the function is called. By using "safe" types,
    this cost is moved to moment when the parameters are constructed.
    Depending on how the program is constructed, this may totally eliminate
    extraneous computions for parameter requirement type checking. In this
    scenario, there is no reason to suppress the checking for release mode and
    our program can be guarenteed to be always arithmetically correct.</p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="idm236255078592"></a>Eliminate runtime cost</h3></div></div></div>
<p>Our system works by checking arithmetic operations whenever they
    could result in an erroneous result. The C++ standard describes how binary
    operations on different integer types are handled. Here is a simplified
    version of the rules:</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>promote any operand smaller than int to an int or unsigned
        int.</p></li>
<li class="listitem"><p>if the signed operand is larger than the signed one, the result
        will be signed, otherwise the result will be unsigned.</p></li>
<li class="listitem"><p>expand the smaller operand to the size of the larger one</p></li>
</ul></div>
<p>So the result of the sum of two integer types will result in another
    integer type. If the values are large, they will exceed the size that the
    resulting integer type can hold. This is what we call "overflow". Standard
    C++ just truncates the result to fit into the result type - which makes
    the result arithmetically incorrect. Up until now, we've focused on
    detecting when this happens and invoking an interrupt or other kind of
    error handler. But now we look at another option. Using the "automatic"
    type promotion policy, we can change the rules of C++ arithmetic for safe
    types to something like the following:</p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>for any C++ numeric types, we know from
          <code class="computeroutput">std::numeric::limits</code> what the maximum and minimum
          values that a variable can be - this defines a closed
          interval.</p></li>
<li class="listitem"><p>For any binary operation on these types, we can calculate the
          interval of the result.</p></li>
<li class="listitem"><p>From this we can determine a new safe type which can be
          guarenteed to hold the result.</p></li>
<li class="listitem"><p>Since the result type is guarenteed to hold the result, there
          is no need to check for errors - they can't happen !!!</p></li>
<li class="listitem"><p>The only error checking we need to do is when safe values are
          initialized, but this we would have to do in any case. So we've
          eliminated arithmetically incorrect results while incurring zero
          runtime overhead for error checking.</p></li>
</ul></div>
<p>In sort, given a binary operation, we promote the constituent types
    to a larger result type which can't overflow. This is a fundamental
    deparature from the C++ Standard behavior.</p>
<p>If the interval of the result cannot be contained in the largest
    type that the machine can handle (usually 64 bits these days), the largest
    available integer type with the correct result sign is used. So even with
    our "automatic" type promotion scheme, it's still possible to overflow. In
    this case, and only this case, is runtime error checking code generated.
    Depending on the application, it should be rare to generate error checking
    code, and even more rare to actually invoke it.</p>
<p>This small example illustrates how to use type promotion and how it
    works.</p>
<pre class="programlisting">#include &lt;cassert&gt;
#include &lt;stdexcept&gt;
#include &lt;ostream&gt;
#include &lt;iostream&gt;
#include &lt;cxxabi.h&gt;

#include "../include/safe_range.hpp"
#include "../include/automatic.hpp"

template &lt;
    std::intmax_t Min,
    std::intmax_t Max
&gt;
using safe_t = boost::numeric::safe_signed_range&lt;
    Min,
    Max,
    boost::numeric::automatic,
    boost::numeric::throw_exception
&gt;;

// I can't figure out how to overload os &lt;&lt; for safe_t
// we use the following workaround there

// wrap a safe_t in a "formatted" wrapper
template&lt;typename T&gt;
struct formatted {
    using wrapped_type = T;
    const T &amp; m_t;
    formatted(const T &amp; t) :
        m_t(t)
    {}
};

template&lt;typename T&gt;
auto make_formatted(const T &amp; t){
    return formatted&lt;T&gt;(t);
}

// now (fully) specialize output of safe types wrapped in formatted
template&lt;
    class T,
    T Min,
    T Max,
    class P, // promotion polic
    class E  // exception policy
&gt;
std::ostream &amp; operator&lt;&lt;(
    std::ostream &amp; os,
    const formatted&lt;boost::numeric::safe_base&lt;T, Min, Max, P, E&gt;&gt; &amp; f
){
    using safe_type = typename formatted&lt;boost::numeric::safe_base&lt;T, Min, Max, P, E&gt; &gt;::wrapped_type;
    return os
        &lt;&lt; "["
        &lt;&lt; std::numeric_limits&lt;safe_type&gt;::min() &lt;&lt; ","
        &lt;&lt; std::numeric_limits&lt;safe_type&gt;::max() &lt;&lt; "] = "
        &lt;&lt; f.m_t;
}

int main(int argc, const char * argv[]){
    // problem: checking of externally produced value can be overlooked
    std::cout &lt;&lt; "example 8: ";
    std::cout &lt;&lt; "eliminate runtime overhead"
    &lt;&lt; std::endl;

    try{
        int status;
        const safe_t&lt;-64, 63&gt; x(1);
        std::cout &lt;&lt; abi::__cxa_demangle(typeid(x).name(),0,0,&amp;status) &lt;&lt; '\n';

        std::cout &lt;&lt; "x" &lt;&lt; make_formatted(x) &lt;&lt; std::endl;
        safe_t&lt;-64, 63&gt; y;
        y = 2;
        std::cout &lt;&lt; "y" &lt;&lt; make_formatted(y) &lt;&lt; std::endl;
        auto z = x + y;
        std::cout &lt;&lt; "(x + y)" &lt;&lt; make_formatted(z) &lt;&lt; std::endl;

        std::cout &lt;&lt; "(x - y)" &lt;&lt; make_formatted(x - y) &lt;&lt; std::endl;
    }
    catch(std::exception e){
        // none of the above should trap. Mark failure if they do
        std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
        return false;
    }

    return 0;
}
</pre>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2012 Robert Ramey<p><a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">Subject to Boost
      Software License</a></p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="introduction.html"><img src="images/prev.png" alt="Prev"></a><a accesskey="u" href="index.html"><img src="images/up.png" alt="Up"></a><a accesskey="h" href="index.html"><img src="images/home.png" alt="Home"></a><a accesskey="n" href="notes.html"><img src="images/next.png" alt="Next"></a>
</div>
</body>
</html>
