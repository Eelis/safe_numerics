<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section PUBLIC "-//Boost//DTD BoostBook XML V1.1//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<section id="safe_numerics.tutorial">
  <title>Tutorial and Motivating Examples</title>

  <section id="safe_numerics.tutorial.1">
    <title>Arithmetic Operations Can Yield Incorrect Results.</title>

    <para>When some operation results in a result which exceeds the capacity
    of a data variable to hold it, the result is undefined. This is called
    "overflow". Since word size can differ between machines, code which
    produces correct results in one set of circumstances may fail when
    re-compiled on a machine with different hardware. When this occurs, Most
    C++ compilers will continue to execute with no indication that the results
    are wrong. It is the programmer's responsibility to ensure such undefined
    behavior is avoided.</para>

    <para>This program demonstrates this problem. The solution is to replace
    instances of <code>char</code> type with <code>safe&lt;char&gt;</code>
    type.</para>

    <programlisting><xi:include href="../../examples/example1.cpp"
        parse="text" xmlns:xi="http://www.w3.org/2001/XInclude"/></programlisting>

    <para>Note that I've used <code>char</code> types in this example to make
    the problem and solution easier to see. The exact same example could have
    been done with <code>int</code> types albeit with different values.</para>
  </section>

  <section id="safe_numerics.tutorial.2">
    <title>Undetected Overflow</title>

    <para>A variation of the above is when a value is incremented/decremented
    beyond it's domain. This is a common problem with for loops.</para>

    <programlisting><xi:include href="../../examples/example2.cpp"
        parse="text" xmlns:xi="http://www.w3.org/2001/XInclude"/></programlisting>

    <para>When variables of unsigned integer type are decremented below zero,
    they "roll over" to the highest possible unsigned version of that integer
    type. This is a common problem which is generally never detected.</para>
  </section>

  <section id="safe_numerics.tutorial.4">
    <title>Implicit Conversions Change Data Values</title>

    <para>A simple assignment or arithmetic expression will convert all the
    terms to the same type. Sometimes this can silently change values. For
    example, when a signed data variable contains a negative type, assigning
    to a unsigned type will be permitted by any C/C++ compiler but will be
    treated as large unsigned value. Most modern compilers will emit a compile
    time warning when this conversion is performed. The user may then decide
    to change some data types or apply a <code>static_cast</code>. This is
    less than satisfactory for two reasons:</para>

    <para><itemizedlist>
        <listitem>
          <para>It may be unwieldy to change all the types to signed or
          unsigned.</para>
        </listitem>

        <listitem>
          <para>We may believe that our signed type will never contain a
          negative value. <code>static_cast</code> changes the data type - not
          the data value. If we ignore the any compiler warnings or use a
          <code>static_cast</code> to suppress them, we'll fail to detect a
          program error when it is committed. This is aways a risk with
          casts.</para>
        </listitem>
      </itemizedlist></para>

    <para>This solution is simple, Just replace instances of the <code>int
    </code>with <code>safe&lt;int&gt;</code>.<programlisting><xi:include
          href="../../examples/example4.cpp" parse="text"
          xmlns:xi="http://www.w3.org/2001/XInclude"/></programlisting></para>
  </section>

  <section id="safe_numerics.tutorial.5">
    <title>Array Index Value Can Exceed Array Limits</title>

    <para>Using an intrinsic C++ array, it's very easy to exceed array limits.
    This can fail to be detected when it occurs and create bugs which are hard
    to find. There are several ways to address this, but one of the simplest
    would be to use safe_unsigned_range;</para>

    <para><programlisting><xi:include href="../../examples/example5.cpp"
          parse="text" xmlns:xi="http://www.w3.org/2001/XInclude"/></programlisting>Collections
    like standard arrays, vectors do array index checking in some function
    calls and not in others so this may not be the best example. However it
    does illustrate the usage of <code>safe_range&lt;T&gt;</code> for
    assigning legal range to variables. This will guarantee that under no
    circumstances will the variable contain a value outside of the specified
    range.</para>
  </section>

  <section id="safe_numerics.tutorial.6">
    <title>Checking of Input Values Can Be Easily Overlooked</title>

    <para>It's way too easy to overlook the checking of parameters received
    from outside the current program.<programlisting><xi:include
          href="../../examples/example6.cpp" parse="text"
          xmlns:xi="http://www.w3.org/2001/XInclude"/></programlisting>Without
    safe integer, one will have to insert new code every time an integer
    variable is retrieved. This is a tedious and error prone procedure. Here
    we have used program input. But in fact this problem can occur with any
    externally produced input.</para>
  </section>

  <section id="safe_numerics.tutorial.7">
    <title>Programming by Contract is Too Slow</title>

    <para>Programming by Contract is a highly regarded technique. There has
    been much written about it has been proposed as an addition to the C++
    language <citation>Garcia</citation><citation>Crowl &amp;
    Ottosen</citation>. It (mostly) depends upon runtime checking of parameter
    and object values upon entry to and exit from every function. This can
    slow the program down considerably which in turn undermines the main
    motivation for using C++ in the first place! One popular scheme for
    addressing this issue is to enable parameter checking only during
    debugging and testing which defeats the guarentee of correctness which we
    are seeking here! Programming by Contract will never be accepted by
    programmers as long as it is associated with significant additional
    runtime cost.</para>

    <para>The Safe Numerics Library has facilities which, in many cases, can
    check guarentee parameter requirements with little or no runtime overhead.
    Consider the following example:</para>

    <para><programlisting><xi:include href="../../examples/example7.cpp"
          parse="text" xmlns:xi="http://www.w3.org/2001/XInclude"/></programlisting></para>

    <para>In the example above the function convert incurs significant runtime
    cost every time the function is called. By using "safe" types, this cost
    is moved to moment when the parameters are constructed. Depending on how
    the program is constructed, this may totally eliminate extraneous
    computations for parameter requirement type checking. In this scenario,
    there is no reason to suppress the checking for release mode and our
    program can be guaranteed to be always arithmetically correct.</para>
  </section>

  <section id="safe_numerics.tutorial.8">
    <title>Eliminate Runtime Cost</title>

    <para>Our system works by checking arithmetic operations whenever they
    could result in an erroneous result. The C++ standard describes how binary
    operations on different integer types are handled. Here is a simplified
    version of the rules:</para>

    <itemizedlist>
      <listitem>
        <para>promote any operand smaller than int to an int or unsigned
        int.</para>
      </listitem>

      <listitem>
        <para>if the signed operand is larger than the signed one, the result
        will be signed, otherwise the result will be unsigned.</para>
      </listitem>

      <listitem>
        <para>expand the smaller operand to the size of the larger one</para>
      </listitem>
    </itemizedlist>

    <para>So the result of the sum of two integer types will result in another
    integer type. If the values are large, they will exceed the size that the
    resulting integer type can hold. This is what we call "overflow". Standard
    C/C++ just truncates the result to fit into the result type - which makes
    the result arithmetically incorrect. This behavior is consistent with the
    default <link
    linkend="safe_numerics.promotion_policy.models.native">"native" type
    promotion policy</link>. Up until now, we've focused on detecting when
    this happens and invoking an interrupt or other kind of error
    handler.</para>

    <para>But now we look at another option. Using the <link
    linkend="safe_numerics.promotion_policy.models.automatic">"automatic" type
    promotion policy</link>, we can change the rules of C++ arithmetic for
    safe types to something like the following:</para>

    <para><itemizedlist>
        <listitem>
          <para>for any C++ numeric types, we know from
          <code>std::numeric::limits</code> what the maximum and minimum
          values that a variable can be - this defines a closed
          interval.</para>
        </listitem>

        <listitem>
          <para>For any binary operation on these types, we can calculate the
          interval of the result at compile time.</para>
        </listitem>

        <listitem>
          <para>From this interval we can determine a new safe type which can
          be guaranteed to hold the result.</para>
        </listitem>

        <listitem>
          <para>Since the result type is guaranteed to hold the result, there
          is no need to check for errors - they can't happen !!!</para>
        </listitem>

        <listitem>
          <para>The only error checking we need to do is when safe values are
          initialized or assigned, but this we would have to do in any case.
          So we've eliminated arithmetically incorrect results while incurring
          zero runtime overhead for error checking.</para>
        </listitem>
      </itemizedlist></para>

    <para>In short, given a binary operation, we promote the constituent types
    to a larger result type which can't overflow. This is a fundamental
    departure from the C++ Standard behavior.</para>

    <para>If the interval of the result cannot be contained in the largest
    type that the machine can handle (usually 64 bits these days), the largest
    available integer type with the correct result sign is used. So even with
    our "automatic" type promotion scheme, it's still possible to overflow. In
    this case, and only this case, is runtime error checking code generated.
    Depending on the application, it should be rare to generate error checking
    code, and even more rare to actually invoke it.</para>

    <para>This small example illustrates how to use type promotion and how it
    works.</para>

    <para><programlisting><xi:include href="../../examples/example8.cpp"
          parse="text" xmlns:xi="http://www.w3.org/2001/XInclude"/></programlisting>The
    above program produces the following output:</para>

    <para><programlisting>example 8: eliminate runtime overhead
x&lt;signed char&gt;[-24,82] = 1
y&lt;signed char&gt;[-24,82] = 2
(x + y)&lt;short&gt;[-48,164] = 3
(x - y)&lt;signed char&gt;[-106,106] = -1</programlisting>Variables x and y
    are stored as 8 bit signed integers with range specified as -24 to 82. The
    result of x + y could be any value in the range -48 to 164. Since this
    result can't be stored in an 8 bit signed integer, a 16 bit signed integer
    is allocated. The result x - y could range from -106 to 106 so will fit in
    an 8 bit signed integer is allocated. Binary operations with safe numeric
    using automatic type promotion will produce other safe numeric types with
    template parameters appropriate to hold the result. The resultant safe
    types may have smaller or larger ranges than the parameters of the binary
    operation.</para>

    <para>We've used simple expressions in this illustration. But since binary
    operations on safe types result in other safe types, expressions can be
    made arbitrarily elaborate - just as they can be with intrinsic integer
    types. That is, safe integer types are drop in replacements for intrinsic
    integer types. We are guaranteed never to produce an incorrect result
    regardless of how elaborate the expression might be.</para>
  </section>
</section>
