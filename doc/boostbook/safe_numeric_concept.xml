<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section PUBLIC "-//Boost//DTD BoostBook XML V1.1//EN"
"http://www.boost.org/tools/boostbook/dtd/boostbook.dtd">
<section id="safe_numerics.safe_numeric_concept">
  <title>SafeNumeric&lt;T&gt;</title>

  <section>
    <title>Description</title>

    <para>This holds an arithmetic value which can be used as a replacement
    for built-in C++ arithmetic values. These types differ from their built-in
    counter parts in that the are guaranteed not to produce invalid arithmetic
    results.</para>
  </section>

  <section>
    <title>Refinement of</title>

    <para><link linkend="safe_numerics.numeric">Numeric</link></para>
  </section>

  <section>
    <title>Notation</title>

    <informaltable>
      <tgroup cols="2">
        <colspec align="left" colwidth="2*"/>

        <colspec align="left" colwidth="10*"/>

        <thead>
          <row>
            <entry align="left">Symbol</entry>

            <entry align="left">Description</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><code>T, U</code></entry>

            <entry>Types fulfilling <link
            linkend="safe_numerics.numeric">Numeric</link> type
            requirements</entry>
          </row>

          <row>
            <entry>t, u</entry>

            <entry>objects of types T, U</entry>
          </row>

          <row>
            <entry>S</entry>

            <entry>A type fulfilling SafeNumeric type requirements</entry>
          </row>

          <row>
            <entry>s, s1, s2</entry>

            <entry>objects of types S</entry>
          </row>

          <row>
            <entry>op</entry>

            <entry>C++ infix operator</entry>
          </row>

          <row>
            <entry>prefix_op</entry>

            <entry>C++ prefix operator</entry>
          </row>

          <row>
            <entry>postfix_op</entry>

            <entry>C++ postfix operator</entry>
          </row>

          <row>
            <entry>assign_op</entry>

            <entry>C++ assignment operator</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
  </section>

  <section>
    <title>Valid Expressions</title>

    <para><informaltable>
        <tgroup cols="3">
          <colspec align="left" colwidth="2*"/>

          <colspec align="left" colwidth="2*"/>

          <colspec align="left" colwidth="8*"/>

          <thead>
            <row>
              <entry align="left">Expression</entry>

              <entry align="left">Result Type</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><code>s op u</code></entry>

              <entry>unspecified S</entry>

              <entry><para>invoke safe C++ operator op and return another
              SafeNumeric type</para></entry>
            </row>

            <row>
              <entry><code>t op s</code></entry>

              <entry>unspecified S</entry>

              <entry><para>invoke safe C++ operator op and return another
              SafeNumeric type</para></entry>
            </row>

            <row>
              <entry><code>s1 op s2</code></entry>

              <entry>unspecified S</entry>

              <entry><para>invoke safe C++ operator op and return another
              SafeNumeric type</para></entry>
            </row>

            <row>
              <entry><code>s1 assign_op s2</code></entry>

              <entry>unspecified S</entry>

              <entry><para>invoke safe C++ operator op and return another
              SafeNumeric type</para></entry>
            </row>

            <row>
              <entry><code>prefix_op S</code></entry>

              <entry>unspecified S</entry>

              <entry><para>invoke safe C++ operator op and return another
              SafeNumeric type</para></entry>
            </row>

            <row>
              <entry><code>S postfix_op</code></entry>

              <entry>unspecified S</entry>

              <entry><para>invoke safe C++ operator op and return another
              SafeNumeric type</para></entry>
            </row>

            <row>
              <entry><code>S(t)</code></entry>

              <entry>unspecified S</entry>

              <entry><para>construct a instance of S from a value
              t</para></entry>
            </row>

            <row>
              <entry><code>S</code></entry>

              <entry>S</entry>

              <entry><para>construct a uninitialized instance of
              S</para></entry>
            </row>

            <row>
              <entry><code>is_safe&lt;S&gt;</code></entry>

              <entry>std::true_type or std::false_type</entry>

              <entry><para>type trait to query whether any type T fulfills the
              requirements for a SafeNumeric type.</para></entry>
            </row>

            <row>
              <entry><code>static_cast&lt;T&gt;(s)</code></entry>

              <entry>T</entry>

              <entry><para>convert the value of s to type T. If the value of s
              cannot be correctly represented as a type T, it is an
              error.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable></para>

    <para>The key fact documented in the above table is that the result of any
    binary operation where one or both of the operands is a SafeNumeric type
    is also a SafeNumeric type. Also note that all the expressions in the
    above table are <code>constexpr</code> expressions. So that if they are
    invoked with constant values, the result will be available a compile
    time.</para>
  </section>

  <section>
    <title>Complexity Guarantees</title>

    <para>There are no explicit complexity guarantees here. However, it would
    be very surprising if any implementation were to be more complex that
    O(0);</para>
  </section>

  <section>
    <title>Invariants</title>

    <para>The fundamental requirement of a SafeNumeric type is that implements
    all C++ operations permitted on it's base type in a way the prevents the
    return of an incorrect arithmetic result. Various implementations of this
    concept may handle circumstances which produce such results differently (
    throw exception, compile time trap, etc..) no implementation should return
    an arithmetically incorrect result.</para>
  </section>

  <section>
    <title>Header</title>

    <para><ulink
    url="../../include/concept/exception_policy.hpp"><code>#include
    &lt;safe_numerics/include/concepts/safe_numeric.hpp&gt;</code></ulink></para>
  </section>

  <section>
    <title>Models</title>

    <para>boost::numeric::safe&lt;T&gt;</para>

    <para>boost::numeric::safe_signed_range&lt;-11, 11&gt;</para>

    <para>boost::numeric::safe_unsigned_range&lt;0, 11&gt;</para>
  </section>
</section>
