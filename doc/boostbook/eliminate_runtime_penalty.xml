<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section PUBLIC "-//Boost//DTD BoostBook XML V1.1//EN"
"http://www.boost.org/tools/boostbook/dtd/boostbook.dtd">
<section id="safe_numerics.tutorial.8">
  <title>Eliminating Runtime Penalty</title>

  <para>Up until now, we've focused on detecting when this happens and
  handling either by throwing an exception or invoking some designated
  function. We've achieved our goal of enforcing arithmetically correct
  behavior - but at what cost. For many C++ program any any runtime penalty is
  unacceptable. Whether or not one agrees with this, its a fact that many C++
  programmers feel this way. So the question arises as to how we alter our
  program to eliminate any runtime penalty.</para>

  <para>The first step is to determine what parts might invoke exceptions. The
  following program is similar to previous examples but uses a special
  exception policy <code>trap_exception</code>. </para>

  <para><programlisting><xi:include href="../../examples/example81.cpp"
        parse="text" xmlns:xi="http://www.w3.org/2001/XInclude"/></programlisting>Now,
  any expression which might fail at runtime is flagged with a compile time
  error. There is no longer any need for <code>try/catch blocks</code>. Since
  this program does not compile, the <emphasis role="bold">library absolutely
  <emphasis role="bold">guarantees that no arithmetic expression</emphasis>
  will yield incorrect results</emphasis> . This is our original goal. Now all
  we need to do is make the program work. There are a couple of ways to do
  this.</para>

  <section>
    <title>Using Automatic Type Promotion</title>

    <para>The C++ standard describes how binary operations on different
    integer types are handled. Here is a simplified version of the
    rules:</para>

    <itemizedlist>
      <listitem>
        <para>promote any operand smaller than int to an int or unsigned
        int.</para>
      </listitem>

      <listitem>
        <para>if the signed operand is larger than the signed one, the result
        will be signed, otherwise the result will be unsigned.</para>
      </listitem>

      <listitem>
        <para>expand the smaller operand to the size of the larger one</para>
      </listitem>
    </itemizedlist>

    <para>So the result of the sum of two integer types will result in another
    integer type. If the values are large, they will exceed the size that the
    resulting integer type can hold. This is what we call "overflow". Standard
    C/C++ does just truncates the result to fit into the result type - which
    sometimes will make the result arithmetically incorrect. </para>

    <para>The complete signature for a safe integer type is:</para>

    <para><programlisting>template &lt;
    class T,                  // underlying integer type
    class P = native,         // type promotion policy class
    class E = throw_exception // error handling policy class
&gt;
safe;
</programlisting></para>

    <para>The standard C++ type promotion rules are consistent with the
    default <link
    linkend="safe_numerics.promotion_policy.models.native">"native" type
    promotion policy</link>. Up until now, we've focused on detecting when
    this happens and invoking an interrupt or other kind of error
    handler.</para>

    <para>But now we look at another option. Using the <link
    linkend="safe_numerics.promotion_policy.models.automatic">"automatic" type
    promotion policy</link>, we can change the rules of C++ arithmetic for
    safe types to something like the following:</para>

    <para><itemizedlist>
        <listitem>
          <para>for any C++ numeric types, we know from
          <code>std::numeric::limits</code> what the maximum and minimum
          values that a variable can be - this defines a closed
          interval.</para>
        </listitem>

        <listitem>
          <para>For any binary operation on these types, we can calculate the
          interval of the result at compile time.</para>
        </listitem>

        <listitem>
          <para>From this interval we can determine a new safe type which can
          be guaranteed to hold the result. This turns out to be a <link
          linkend="safe_numerics.safe_range"><code>safe_range</code></link>
          type.</para>
        </listitem>

        <listitem>
          <para>Since the result type is guaranteed to hold the result, there
          is no need to check for errors - they can't happen !!!</para>
        </listitem>

        <listitem>
          <para>The only runtime error checking we need to do is when safe
          values are initialized or assigned using smaller types. These are
          infrequent occurrences. And many times, one can make small
          adjustments in selecting the types in order to eliminate all runtime
          penalties. This is what has been done in the above example.</para>
        </listitem>
      </itemizedlist></para>

    <para>In short, given a binary operation, we promote the constituent types
    to a larger result type which can't overflow. This is a fundamental
    departure from the C++ Standard behavior.</para>

    <para>If the interval of the result cannot be contained in the largest
    type that the machine can handle (usually 64 bits these days), the largest
    available integer type with the correct result sign is used. So even with
    our "automatic" type promotion scheme, it's still possible to overflow. In
    this case, and only this case, is runtime error checking code generated.
    Depending on the application, it should be rare to generate error checking
    code, and even more rare to actually invoke it.</para>

    <para>This small example illustrates how to use type promotion and how it
    works.</para>

    <para><programlisting><xi:include href="../../examples/example82.cpp"
          parse="text" xmlns:xi="http://www.w3.org/2001/XInclude"/></programlisting></para>

    <para>The above program produces the following output:</para>

    <para><programlisting>example 82:
x&lt;int&gt;[-2147483648,2147483647] = 2147483647
y&lt;int&gt;[-2147483648,2147483647] = 2
z(x + y)&lt;long&gt;[-4294967296,4294967294] = 2147483649
(x - y)&lt;long&gt;[-4294967295,4294967295] = 2147483645
&lt;long&gt;[-4294967296,4294967294] = 2147483649
</programlisting></para>

    <para>The output uses a custom output manipulator for safe types to
    display the underlying type and its range as well as current value. Note
    that:<itemizedlist>
        <listitem>
          <para>automatic type promotion policy has rendered the result of the
          some of two </para>
        </listitem>

        <listitem>
          <para>our program compiles without error - even when using the
          trap_exception exception policy</para>
        </listitem>

        <listitem>
          <para>We do not need to use try/catch idiom to handle arithmetic
          errors - we will have none.</para>
        </listitem>

        <listitem>
          <para>We only needed to change two lines of code to achieve our
          goal</para>
        </listitem>
      </itemizedlist></para>
  </section>

  <section>
    <title>Using <link
    linkend="safe_numerics.safe_range">safe_range</link></title>

    <para>instead of relying on automatic type promotion, you can just create
    your own types in such a way that you known they won't overflow. Here we
    presume we happen to know that the values we want to work with fall in the
    closed range of -24,82. So we "know" the program will always result in a
    correct result. But since we trust no one, and since the program could
    change and the expressions replaced with other ones, we'll still you the
    <code>trap_exception</code> to verify at compile time that what we "know"
    to be true is in fact true.</para>

    <programlisting><xi:include href="../../examples/example83.cpp"
        parse="text" xmlns:xi="http://www.w3.org/2001/XInclude"/></programlisting>

    <para>which produces the following output.</para>

    <programlisting>example 83:
x&lt;signed char&gt;[-24,82] = 1
y&lt;signed char&gt;[-24,82] = 2
z(x + y)&lt;int&gt;[-2147483648,2147483647] = 3
(x - y)&lt;int&gt;[-2147483648,2147483647] = -1
&lt;int&gt;[-2147483648,2147483647] = 3
</programlisting>

    <para>Note that we use a special object - <code>safe_literal</code> to
    initialize safe types. safe_literal is a special safe type which wraps a
    constant defined at compile time. Without this, the compiler will emit
    code to check the value initializing variables x and y and our
    trap_exception compile time error would be invoked. It cannot be assigned
    to, or changed. Subject to this restriction, it can participate in safe
    arithmetic operations. </para>

    <para>Variables x and y are stored as 8 bit signed integers with range
    specified as -24 to 82. The result of x + y could be any value in the
    range -48 to 164. Since this result can't be stored in an 8 bit signed
    integer, a 16 bit signed integer is allocated. The result x - y could
    range from -106 to 106 so will fit in an 8 bit signed integer is
    allocated. Binary operations with safe numeric using automatic type
    promotion will produce other safe numeric types with template parameters
    appropriate to hold the result. The resultant safe types may have smaller
    or larger ranges than the parameters of the binary operation.</para>

    <para>We've used simple expressions in this illustration. But since binary
    operations on safe types result in other safe types, expressions can be
    made arbitrarily elaborate - just as they can be with intrinsic integer
    types. That is, safe integer types are drop in replacements for intrinsic
    integer types. We are guaranteed never to produce an incorrect result
    regardless of how elaborate the expression might be.</para>
  </section>

  <section>
    <title>Miscellaneous</title>

    <para>For purposes of exposition, we've divided the discussion of how to
    eliminate runtime penalties by the different approaches available. A
    realistic program would likely include all techniques mentioned
    above.</para>
  </section>
</section>
